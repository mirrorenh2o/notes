# ABI
ABI（Application Binary Interface）概念

RISC-V的浮点ABI更是因其硬件多样性显得复杂。让我们彻底解析这个问题：

---

### **一、ABI的本质**
ABI是**程序与操作系统/硬件之间的二进制契约**，它定义了：
1. **数据类型**：整数/浮点的尺寸和对齐方式
2. **函数调用规则**：参数如何传递（寄存器/栈）、返回值存放位置
3. **寄存器使用约定**：哪些寄存器由调用者/被调用者保存
4. **系统调用方式**：如何与操作系统交互

类比理解：
- **API**：是源码级的接口约定（人类可读）
- **ABI**：是机器码级的接口约定（硬件/OS可执行）

---

### **二、为什么RISC-V特别强调"浮点ABI"？**
由于RISC-V的模块化设计，浮点处理有**多种硬件实现方式**：
1. **无浮点单元**：纯软件模拟（慢但通用）
2. **单精度浮点**：仅支持`float`（D扩展）
3. **完整浮点**：支持`float`和`double`（F+D扩展）

因此ABI必须明确告知编译器：
- **如何传递浮点参数**（用通用寄存器还是浮点专用寄存器）
- **如何生成浮点指令**（用软件模拟还是硬件指令）

---

### **三、RISC-V ABI命名解析**
#### 1. **基本结构**：`<整数位宽><浮点约定>`
- **前半部分**（如`ilp32`/`lp64`）：
  - `i`：int（32位）
  - `l`：long（32位或64位）
  - `p`：pointer（32位或64位）
  - 例如：`ilp32`表示`int=long=pointer=32位`

- **后半部分**（如空/d/f）：
  | 后缀 | 含义                          | 寄存器使用                |
  |------|-----------------------------|--------------------------|
  | (无) | 无浮点支持                   | 通用寄存器传递浮点数       |
  | d    | 单精度浮点（D扩展）           | 浮点寄存器传递`float`      |
  | f    | 双精度浮点（F+D扩展）         | 浮点寄存器传递`float/double` |

#### 2. **常见组合示例**
| ABI类型   | 适用场景                          | 寄存器使用差异                  |
|-----------|----------------------------------|--------------------------------|
| `ilp32`   | 无浮点的RV32MCU（如GD32VF103）   | 浮点运算会调用软件库            |
| `ilp32d`  | 带单精度浮点的RV32（如K210）     | `float`用`f0-f31`寄存器         |
| `lp64d`   | 64位处理器带双精度浮点           | `double`也用浮点寄存器          |

---

### **四、为什么浮点ABI如此关键？**
#### 1. **硬件兼容性问题**
- 如果芯片只有单精度硬件（D扩展），但用了`ilp32f` ABI：
  ```c
  double foo = 3.14; // 将尝试生成不存在的双精度指令！
  ```
  会导致**非法指令异常**（Illegal Instruction Exception）

#### 2. **性能差异**
| 场景                | 性能对比               |
|---------------------|-----------------------|
| `ilp32d` + 硬件D扩展 | 单精度运算快10-100倍  |
| `ilp32` + 软件模拟   | 所有浮点运算都很慢    |

#### 3. **二进制兼容性**
不同ABI编译的库**无法直接混用**：
```bash
# 错误示例：用ilp32d编译主程序，却链接ilp32的库
riscv64-unknown-elf-gcc -mabi=ilp32d main.c libfoo.a 
# 运行时会因寄存器使用冲突崩溃
```

---

### **五、实际开发中的选择策略**
1. **查看芯片手册**：
   - 确认支持的指令扩展（如`RV32IMAC` vs `RV32IMAFDC`）
   - F/D扩展的存在决定能否用`d/f`后缀

2. **SDK依赖**：
   - 如果使用厂商提供的库（如SiFive的HAL），必须匹配其ABI

3. **典型配置示例**：
   ```bash
   # GD32VF103 (无硬件浮点)
   -march=rv32imac -mabi=ilp32

   # Kendryte K210 (有单精度浮点)
   -march=rv64imafdc -mabi=lp64d

   # 自定义软浮点实现
   -march=rv32ima -mabi=ilp32 -fno-math-errno
   ```

---

### **六、与其他架构的对比**
| 架构    | 浮点处理方式                  | 类似概念               |
|---------|-----------------------------|-----------------------|
| ARM     | -mfloat-abi=hard/soft       | hard对应RISC-V的`d/f`  |
| x86     | 默认SSE指令支持              | 无需显式指定ABI        |
| MSP430  | 纯软件浮点                   | 类似RISC-V无后缀       |

RISC-V的ABI设计更显式，因为其**模块化指令集**允许芯片厂商自由组合功能模块。

---

### **七、总结：浮点ABI的核心作用**
1. **硬件加速开关**：告诉编译器能否使用浮点指令
2. **寄存器分配策略**：决定浮点数的存储位置
3. **二进制兼容基石**：确保库和主程序使用相同的调用约定

---

在RISC-V开发中，除了浮点处理约定外，ABI还需要特别注意以下关键方面的区分，这些都会直接影响二进制兼容性和运行时行为：

### **一、基础整数类型约定**
#### 1. **指针/整数尺寸（ILP32 vs LP64）**
| ABI类型 | int | long | 指针 | 典型应用场景          |
|---------|-----|------|------|-----------------------|
| `ilp32` | 32  | 32   | 32   | RV32微控制器（如GD32VF103）|
| `lp64`  | 32  | 64   | 64   | RV64应用处理器（如HiFive Unmatched）|

**示例问题**：  
若将`lp64`编译的库与`ilp32`程序链接，会导致指针截断（64→32位）引发内存访问错误。

#### 2. **结构体对齐规则**
- 默认对齐值（如`char`按1字节，`int`按4字节对齐）
- 特殊属性控制：
  ```c
  struct __attribute__((packed)) {  // 取消对齐填充
      uint8_t a;
      uint32_t b;
  };
  ```

---

### **二、函数调用约定**
#### 1. **参数传递规则**
| 参数类型       | RV32调用约定                     | RV64调用约定                     |
|----------------|----------------------------------|----------------------------------|
| 整数参数       | a0-a7寄存器（剩余压栈）          | a0-a7寄存器（剩余压栈）          |
| 浮点参数       | 根据ABI后缀（如`ilp32d`用fa0-fa7）| 同上                             |
| 返回值         | a0/a1或fa0/fa1                  | a0/a1或fa0/fa1                   |

**关键差异**：  
`ilp32`和`ilp32d`在传递浮点参数时，会分别使用通用寄存器(a0-a7)和浮点寄存器(fa0-fa7)。

#### 2. **调用者/被调用者保存寄存器**
| 寄存器类型 | RV32保存方      | RV64保存方      |
|------------|----------------|----------------|
| s0-s11     | 被调用者保存    | 被调用者保存    |
| t0-t6      | 调用者保存      | 调用者保存      |
| fa0-fa7    | 根据ABI后缀决定 | 同上            |

---

### **三、系统调用约定**
| 架构    | 系统调用号寄存器 | 参数寄存器       | 返回值寄存器 |
|---------|------------------|------------------|--------------|
| RV32    | a7               | a0-a6            | a0           |
| RV64    | a7               | a0-a6            | a0           |

**注意**：  
虽然系统调用约定在RV32/RV64中相同，但系统调用号的定义可能因OS而异（如Linux与裸机环境不同）。

---

### **四、异常处理机制**
#### 1. **中断上下文保存**
- RV32：需保存32位寄存器状态
- RV64：需保存64位寄存器状态
- 浮点扩展：若启用浮点ABI，还需保存`fcsr`和浮点寄存器

#### 2. **向量表布局**
- 异常入口地址的对齐要求（如4字节对齐或8字节对齐）
- 中断优先级处理方式

---

### **五、内存原子操作**
| 操作类型       | RV32 ABI要求          | RV64 ABI要求          |
|----------------|-----------------------|-----------------------|
| 原子加载/存储  | 需要`A`扩展指令支持   | 需要`A`扩展指令支持   |
| 原子CAS        | 使用lr/sc指令序列     | 同上                  |

若芯片不支持原子扩展（如`RV32I`无`A`扩展），需通过软件临界区实现。

---

### **六、多线程相关**
#### 1. **TLS（线程局部存储）**
- 访问方式：通过`tp`（Thread Pointer）寄存器
- RV32：`tp`为32位地址
- RV64：`tp`为64位地址

#### 2. **锁的实现**
- 自旋锁依赖原子指令
- 互斥锁可能依赖操作系统支持

---

### **七、与浮点ABI的交互影响**
即使不直接使用浮点运算，ABI选择也会影响：
1. **第三方库链接**：若库使用`ilp32d`编译，主程序必须匹配
2. **汇编代码调用**：混合编写汇编与C时需统一寄存器使用方式
3. **性能优化**：错误的ABI会导致不必要的寄存器搬运

---

### **八、实际开发检查清单**
1. **确认芯片规格**：
   ```bash
   # 查看支持的指令集扩展
   riscv64-unknown-elf-objdump -d binary.elf | grep "ecall"
   ```

2. **验证ABI兼容性**：
   ```bash
   # 检查ELF文件的ABI标记
   readelf -A target.elf
   ```

3. **典型错误案例**：
   - 在`ilp32`配置下误用`%f`格式化输出（应使用软件浮点转换）
   - 在无原子扩展的芯片上使用`__atomic_`内置函数

---

### **九、各架构ABI对比表**
| 特性               | RISC-V (`ilp32`) | ARM (`armv7m`) | x86_64        |
|--------------------|------------------|----------------|---------------|
| 指针宽度           | 32-bit           | 32-bit         | 64-bit        |
| 浮点参数传递       | 通用寄存器        | VFP寄存器      | XMM寄存器     |
| 系统调用号寄存器   | a7               | r7             | rax           |
| TLS访问            | `tp`寄存器       | `r9`寄存器     | `fs`段寄存器  |

理解这些ABI细节能帮助你在RISC-V开发中：
- 避免微妙的运行时错误
- 优化关键性能路径
- 正确集成第三方库
- 编写兼容性强的跨平台代码

正确配置ABI是RISC-V开发中**避免运行时错误**和**最大化硬件性能**的关键步骤！当不确定时，优先参考芯片厂商的SDK配置。
